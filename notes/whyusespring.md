Benefits of Spring: focus on core task instead of boilerplate
Design Patterns
Disadvantages:

Inversion of Control container for Java
 Core: Dependency Injection,
Internationalisation
Validation
AOP

Data Access:
Support Java Traction API
Java Persistent API
Java Databse Connectivity

Web:
Spring MVC
Spring Webflux
WebSockets
Stomp
WebClient

Integration to Enterprise using Java Message Service, Java Management Extension and Remote Method Invocation

Testing:
Mock Objects, Test Fixture,Content Management, Caching

Boot,
Cloud
Security
Mobile
Batch

Crud as Rest API
domain Entity
in-memory database
mutation endpoints using basic auth
unit test

Spring Initializr: bootstrap with dependencies
Web, JPA,H2, Security using Maven

Domain Model and Persistence

```
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO) -- autogenerated ID
    private Long id
    @NotNull
    private firstName;
}
```
Define JPA:
```
public interface EmployeeRepository extends CrudRepository<Employee, Long> {
    List<Employee> findAll();
}

```
<b>Controller<b>
handle incoming request
annotate class and define routing meta information along with handler method
```
@RestController
public class EmployeeController {
    @AutoWired
    private EmployeeRepository repository
    @GetMapping("/employees")
    public List<Employee> getEmployees() {
        return repository.findAll();
    }
}
```
<b> Security <b>
To Prevent unauthenticated access to endpoints
Allow Get operations unrestricted 

```

@EnableWebSecurity
piblic class WebSecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests().antMatchers(HttpMethod.GET,"employees","/employees/**")
        .permitAll().anyRequest().authenticated().and().httpBasic();
        return http.build();
    }
}
```
<b>Testing<b>
Unit Testing
```
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvionment = WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
public class EmployeeControllerTests {
    @Autowired
    private MockMvc mcv;
    @Test
    @WithMockUser()
    public void givenNoEmployee_whenCreateEmployee_thenEmployeeCreated() throws Exception {
        mvc.perform(post("/employees").content(new ObjectMapper().writeValueAsString(new Employee("First","Last"))
        .with(csrf())
        .contentType(MediaType.APPLICATION_JSON)
        .accept(MediaType.APPLICATION_JSON)
        .andExpect(MockMvcRestMatchers.status()
        .isCreated())
        .andExpect(jsonPath("$.firstName",is("First")))
        .andExpect(jsonPath("$.lastName",is("Last")))
        ))
    }

}   

```

Benefits of Spring

Usability: configuration makes it easier to start and configure
Modularity: Include modules as necessary, add other framework such as Hibernate or Strut

Conformance
Support JPA repository and easy to switch providers
Support Reactive Stream and Hateoas

Testability: support Test Driven Development
POJOS
Mock Objects for MVC testing


